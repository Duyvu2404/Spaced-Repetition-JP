<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SR 50 từ/ngày — SM-2 + Tổng ôn 7/21 ngày</title>

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans JP", sans-serif; }
    *, *::before, *::after { box-sizing: border-box; }

    body { margin: 0; background: #0b0f14; color: #e8eef7; }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 22px; }
    h1 { margin: 0 0 12px; font-size: 20px; }
    .grid { display: grid; grid-template-columns: 440px 1fr; gap: 14px; }
    @media (max-width: 1020px) { .grid { grid-template-columns: 1fr; } }
    .card { background: #121a24; border: 1px solid #1f2a39; border-radius: 14px; padding: 14px; }
    .meta { display: flex; gap: 10px; flex-wrap: wrap; margin: 8px 0 12px; color: #b6c4d9; }
    .pill { background: #0f1620; border: 1px solid #243246; padding: 8px 10px; border-radius: 999px; }

    input, textarea, select, button {
      border-radius: 12px; border: 1px solid #243246; background: #0f1620; color: #e8eef7;
      padding: 11px 12px; font-size: 14px; outline: none;
      max-width: 100%;
    }
    textarea { width: 100%; min-height: 160px; resize: vertical; line-height: 1.35; }
    input::placeholder, textarea::placeholder { color: #91a2ba; }
    button { cursor: pointer; background: #1a2a40; border-color: #2a3b56; font-weight: 750; }
    button:disabled { opacity: .45; cursor: not-allowed; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    .small { color: #b6c4d9; font-size: 13px; margin-top: 10px; line-height: 1.35; }
    .ok { color: #9ee6b8; }
    .warn { color: #ffd59a; }
    .err { color: #ffb3b3; }
    .sep { height: 1px; background: #1f2a39; margin: 12px 0; }
    .kicker{ font-size:12px; color:#b6c4d9; }
    .muted{ color:#93a7c2; }

    .headbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
      margin: 0 0 10px;
    }
    .schedule{
      background:#0f1620; border:1px solid #243246; border-radius:12px;
      padding: 10px 12px; color:#c8d6ea; font-size: 13px;
    }
    .schedule b { color:#e8eef7; }

    .tableWrap{
      overflow:auto; border:1px solid #1f2a39; border-radius: 12px; background:#0f1620;
      max-height: 72vh;
    }
    table{ width:100%; border-collapse: collapse; min-width: 1180px; }
    thead th{
      position: sticky; top: 0; z-index: 3;
      background:#101a27; border-bottom:1px solid #1f2a39;
      padding: 10px; text-align:left; font-size: 13px;
      white-space: nowrap;
    }
    tbody td{
      border-top:1px solid #1a2535; padding: 10px; font-size: 13px; vertical-align: top;
    }
    tbody td.blank{ height: 46px; }

    .historyWrap{
      overflow:auto; border:1px solid #1f2a39; border-radius: 12px; background:#0f1620;
      max-height: 240px; margin-top: 10px;
    }
    .historyTable{ min-width: 100%; }
    .historyTable thead th{ position: sticky; top: 0; }

    .danger { background: #3a1a1a; border-color: #5a2a2a; }
    .btnMini{
      padding: 8px 10px;
      font-size: 12px;
      border-radius: 10px;
      white-space: nowrap;
    }

    /* Marking cells */
    td.markable { cursor: pointer; user-select: none; text-align: center; font-weight: 900; }
    td.markable.pass { color: #9ee6b8; }
    td.markable.fail { color: #ffb3b3; }
    td.markable:hover { background: #12263a; }

    /* created date as superscript (only shown on TRI review days) */
    sup.createdDate {
      font-size: 10px;
      font-weight: 800;
      color: #93a7c2;
      margin-left: 4px;
    }
  </style>
</head>

<body>
<div class="wrap">
  <h1>Spaced Repetition — Japanese Learning</h1>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="meta">
        <div class="pill" id="todayPill"></div>
        <div class="pill" id="modePill"></div>
        <div class="pill" id="newPill"></div>
        <div class="pill" id="duePill"></div>
        <div class="pill" id="weakPill"></div>
        <div class="pill" id="totalPill"></div>
      </div>

      <div id="reviewNotice" class="kicker warn" style="display:none; margin: 8px 0 10px;"></div>

      <!-- BULK SECTION (ẩn ở ngày tổng ôn 7/21) -->
      <div id="bulkSection">
        <div style="font-weight:800; margin-bottom:8px;">Nhập nhanh (dán nhiều dòng)</div>
        <div class="kicker">
          Mỗi dòng: <b>Từ vựng</b> [TAB hoặc | hoặc ,] <b>Kana</b> [TAB hoặc | hoặc ,] <b>Nghĩa Việt</b><br>
          Ví dụ: <span class="muted">食べる | たべる | ăn</span>
        </div>
        <textarea id="bulkText" placeholder="Dán danh sách 50 từ ở đây..."></textarea>
        <div class="actions">
          <button id="bulkAddBtn" type="button">Thêm hàng loạt</button>
          <button id="bulkClearBtn" type="button">Xóa ô nhập</button>
        </div>

        <div class="sep"></div>
      </div>

      <div style="font-weight:800; margin-bottom:6px;">Giờ bắt đầu học hôm nay (tùy chọn)</div>
      <div class="kicker">
        Nếu chọn, hệ thống tự chia <b>5 mốc</b> trong ngày và <b>không qua 00:00</b>.<br>
        Nếu không chọn, dùng mốc cố định: <span class="muted">08:00 · 11:00 · 14:00 · 18:00 · 22:00</span>.
      </div>

      <div class="actions" style="margin-top:10px;">
        <input id="startTimeInput" type="time" step="60" style="flex:1; min-width: 160px;">
        <button id="applyStartTimeBtn" type="button">Áp dụng cho hôm nay</button>
        <button id="resetStartTimeBtn" type="button">Về mặc định</button>
      </div>
      <div class="kicker muted" id="startTimeHint" style="margin-top:6px;"></div>

      <div class="actions" style="margin-top:12px;">
        <button id="genBtn" type="button">Tạo file kiểm tra hôm nay</button>
      </div>

      <div class="actions" id="resultActions" style="margin-top:10px; display:none;">
        <button id="finalizeBtn" type="button">Hoàn tất & cập nhật SR</button>
        <button id="markPassAllBtn" type="button" class="btnMini">Đạt hết (cột cuối)</button>
        <button id="clearMarksBtn" type="button" class="btnMini danger">Xóa đánh dấu</button>
      </div>
      <div class="kicker muted" id="resultHint" style="margin-top:6px;"></div>

      <div class="small" id="msg"></div>

      <div class="sep"></div>

      <div style="font-weight:800;">Kho lưu trữ lịch sử (xem lại theo ngày)</div>
      <div class="kicker" style="margin-top:6px;">Chọn ngày để xem danh sách từ đã nhập hôm đó (có thể sửa/xóa từng từ).</div>
      <select id="historyDateSelect" style="width:100%; margin-top:10px;"></select>

      <div class="historyWrap">
        <table class="historyTable">
          <thead>
            <tr>
              <th style="width:28%;">Từ vựng</th>
              <th style="width:28%;">Kana</th>
              <th style="width:34%;">Nghĩa Việt</th>
              <th style="width:10%;">Thao tác</th>
            </tr>
          </thead>
          <tbody id="historyBody"></tbody>
        </table>
      </div>

      <div class="actions" style="margin-top:10px;">
        <button id="clearLocalBtn" class="danger" type="button">Xóa dữ liệu local</button>
      </div>
      <div class="kicker muted" style="margin-top:6px;">
        (Sẽ xóa toàn bộ lịch sử trên máy này và reset toàn bộ hệ thống.)
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="headbar">
        <div style="font-weight:800;">Xem trước bảng in (live — hôm nay)</div>
        <div class="schedule" id="scheduleHeader"></div>
      </div>

      <div class="tableWrap">
        <table>
          <thead>
            <tr id="previewHeadRow"></tr>
          </thead>
          <tbody id="previewBody"></tbody>
        </table>
      </div>

      <div class="small muted" style="margin-top:10px;">
        Click ô trống để chấm: <b>Trống → ✓ → ✗ → Trống</b>. SR (SM-2) chỉ cập nhật khi bấm <b>Hoàn tất</b>.<br>
        <b>Chỉ ngày tổng ôn 21 (ôn hết tất cả từ)</b> mới hiện <b>ngày tạo</b> dạng <b>superscript</b>.
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ======= CẤU HÌNH =======
  const TZ = "Asia/Bangkok";
  const DAILY_NEW_LIMIT = 50;

  // Review days
  const WEEKLY_EVERY_DAYS = 7;   // tổng ôn 7 ngày
  const WEEKLY_WINDOW_DAYS = 7;  // lấy 7 ngày gần nhất (bao gồm hôm nay)
  const TRI_EVERY_DAYS = 21;     // tổng ôn 21 ngày (cộng dồn từ startDate đến hôm nay)

  // Weak boosters
  const WEAK_DAILY_LIMIT = 20;   // ngày thường
  const WEAK_WEEKLY_LIMIT = 30;  // ngày tổng ôn 7 ngày

  // mốc mặc định
  const DEFAULT_DAILY_CYCLE = ["08:00", "11:00", "14:00", "18:00", "22:00"];

  // nhịp cũ (scale theo thời gian còn lại)
  const SHAPE_OFFSETS_MIN = [0, 180, 360, 600, 840];
  const SHAPE_SPAN_MIN = SHAPE_OFFSETS_MIN[SHAPE_OFFSETS_MIN.length - 1];

  // cột viết = 1 (Học mới) + 5 (giờ)
  const BLANK_COLS = 1 + DEFAULT_DAILY_CYCLE.length;

  // ======= TIỆN ÍCH NGÀY =======
  const todayStr = () => new Intl.DateTimeFormat("en-CA", {
    timeZone: TZ, year: "numeric", month: "2-digit", day: "2-digit"
  }).format(new Date());

  const ymdToDay = (ymd) => {
    const [y,m,d] = (ymd || "1970-01-01").split("-").map(Number);
    return Math.floor(Date.UTC(y, m-1, d) / 86400000);
  };
  const dayToYmd = (day) => new Date(day * 86400000).toISOString().slice(0,10);
  const addDays = (ymd, delta) => dayToYmd(ymdToDay(ymd) + delta);

  const timeToMin = (hhmm) => {
    const [h,m] = (hhmm || "00:00").split(":").map(Number);
    return (h*60 + m) || 0;
  };
  const minToHHMM = (min) => {
    const mm = Math.max(0, Math.min(1439, Math.floor(min)));
    const h = Math.floor(mm/60);
    const m = mm % 60;
    return String(h).padStart(2,"0") + ":" + String(m).padStart(2,"0");
  };

  // ======= RNG ỔN ĐỊNH =======
  function xmur3(str) {
    let h = 1779033703 ^ str.length;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function() {
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      return (h ^= (h >>> 16)) >>> 0;
    };
  }
  const orderKey = (seed, id) => xmur3(seed + "::" + id)();

  // ======= LƯU TRỮ (có migrate) =======
  const KEY = "sr_50_final_sm2_7_21";
  const LEGACY_KEYS = [
    "sr_50_v5_sm2_weekly_tri",
    "sr_50_v4_sm2_weekly_cycle",
    "sr_50_v3_sm2_weekly_weak",
    "sr_50_v2_sm2",
    "sr_50_v2"
  ];

  const defaultState = () => ({
    startDate: null,
    words: [],
    settings: { cycleStartByDate: {} },
    generatedByDate: {}
  });

  const tryLoad = (k) => {
    const raw = localStorage.getItem(k);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  };

  const load = () => {
    let s = tryLoad(KEY);
    if (!s) {
      for (const k of LEGACY_KEYS) {
        const legacy = tryLoad(k);
        if (legacy) { s = legacy; break; }
      }
    }
    if (!s) return defaultState();
    if (!s.words) s.words = [];
    if (!s.settings) s.settings = { cycleStartByDate: {} };
    if (!s.settings.cycleStartByDate) s.settings.cycleStartByDate = {};
    if (!s.generatedByDate) s.generatedByDate = {};
    return s;
  };

  const save = (s) => localStorage.setItem(KEY, JSON.stringify(s));
  let state = load();
  save(state);

  // ======= SR (SM-2) =======
  const normalizeCard = (w) => {
    if (!w.due && w.nextDue) w.due = w.nextDue;
    if (!w.lastReviewed && w.lastSeen) w.lastReviewed = w.lastSeen;

    if (w.ef == null) w.ef = 2.5;
    if (w.reps == null) w.reps = 0;
    if (w.interval == null) w.interval = 0;
    if (!w.due) w.due = w.addedDate;
    if (w.lapses == null) w.lapses = 0;
    if (w.failStreak == null) w.failStreak = 0;
    if (w.lastQ == null) w.lastQ = null;
    if (!("lastReviewed" in w)) w.lastReviewed = null;

    if ("stage" in w) delete w.stage;
    if ("nextDue" in w) delete w.nextDue;
    if ("lastSeen" in w) delete w.lastSeen;

    return w;
  };

  const computeEF = (ef, q) => {
    const next = ef + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02));
    return Math.max(1.3, Number.isFinite(next) ? next : 2.5);
  };

  const sm2Update = (card, quality, today) => {
    normalizeCard(card);
    const q = Math.max(0, Math.min(5, quality));
    card.ef = computeEF(card.ef, q);

    if (q < 3) {
      card.reps = 0;
      card.interval = 1;
      card.lapses = (card.lapses ?? 0) + 1;
      card.failStreak = (card.failStreak ?? 0) + 1;
    } else {
      card.failStreak = 0;
      if (card.reps === 0) card.interval = 1;
      else if (card.reps === 1) card.interval = 6;
      else card.interval = Math.max(1, Math.round(card.interval * card.ef));
      card.reps += 1;
    }

    card.lastQ = q;
    card.due = addDays(today, card.interval);
    card.lastReviewed = today;
  };

  // ======= START DATE =======
  const ensureStartDate = () => {
    if (state.startDate) return;
    if (state.words.length === 0) return;
    const minDay = Math.min(...state.words.map(w => ymdToDay(w.addedDate)));
    state.startDate = dayToYmd(minDay);
    save(state);
  };

  const idxFromStart = (t) => {
    if (!state.startDate) return null;
    return (ymdToDay(t) - ymdToDay(state.startDate)) + 1;
  };

  const isTriReviewDay = (t) => {
    const idx = idxFromStart(t);
    if (!idx) return false;
    return idx % TRI_EVERY_DAYS === 0;
  };

  const isWeeklyReviewDay = (t) => {
    const idx = idxFromStart(t);
    if (!idx) return false;
    // ưu tiên 21-day: nếu rơi đúng ngày 21 thì coi là tri, không phải weekly
    if (idx % TRI_EVERY_DAYS === 0) return false;
    return idx % WEEKLY_EVERY_DAYS === 0;
  };

  const getModeForDate = (t) => {
    if (isTriReviewDay(t)) return "tri";
    if (isWeeklyReviewDay(t)) return "weekly";
    return "daily";
  };

  const isReviewOnlyDay = (t) => {
    const m = getModeForDate(t);
    return m === "weekly" || m === "tri";
  };

  // ======= COUNTS =======
  const countNewOnDate = (d) => state.words.filter(w => w.addedDate === d).length;

  const dueCountOnDate = (t) => {
    const tDay = ymdToDay(t);
    return state.words
      .map(normalizeCard)
      .filter(w => w.addedDate !== t && ymdToDay(w.due) <= tDay)
      .length;
  };

  // ======= WEAK PICKER =======
  const weakScore = (w) => {
    normalizeCard(w);
    let s = 0;
    s += (w.failStreak ?? 0) * 80;
    s += (w.lapses ?? 0) * 20;
    s += Math.round((2.6 - (w.ef ?? 2.5)) * 30);
    if ((w.reps ?? 0) <= 1) s += 15;
    if (w.lastQ != null && w.lastQ < 3) s += 30;
    return s;
  };

  const pickWeakWords = (t, limit, excludeSet) => {
    const tDay = ymdToDay(t);
    const candidates = state.words
      .map(normalizeCard)
      .filter(w => {
        if (excludeSet.has(w.id)) return false;
        if (w.addedDate === t) return false;
        if (ymdToDay(w.due) <= tDay) return false;
        return weakScore(w) >= 25;
      })
      .map(w => ({ w, s: weakScore(w) }));

    candidates.sort((a,b)=> b.s - a.s);
    return candidates.slice(0, limit).map(x => x.w);
  };

  // ======= POOL BUILDER =======
  const buildSessionPool = (t) => {
    const tDay = ymdToDay(t);
    const seed = "seed:" + t;

    const mode = getModeForDate(t);
    const tri = (mode === "tri");
    const weekly = (mode === "weekly");

    const todayNew = state.words
      .filter(w => w.addedDate === t)
      .slice(0, DAILY_NEW_LIMIT)
      .map(normalizeCard);

    const setNew = new Set(todayNew.map(w => w.id));

    const due = state.words
      .map(normalizeCard)
      .filter(w => !setNew.has(w.id) && ymdToDay(w.due) <= tDay);

    let weeklyPack = [];
    if (weekly) {
      const startDay = tDay - (WEEKLY_WINDOW_DAYS - 1);
      weeklyPack = state.words
        .map(normalizeCard)
        .filter(w => {
          const d = ymdToDay(w.addedDate);
          return d >= startDay && d <= tDay;
        });
    }

    // TRI: tổng ôn “hết tất cả từ” = cộng dồn từ startDate đến hôm nay
    let triPack = [];
    if (tri) {
      const startDay = state.startDate ? ymdToDay(state.startDate) : tDay;
      triPack = state.words
        .map(normalizeCard)
        .filter(w => {
          const d = ymdToDay(w.addedDate);
          return d >= startDay && d <= tDay;
        });
    }

    const map = new Map();
    for (const w of triPack) map.set(w.id, w);
    for (const w of weeklyPack) map.set(w.id, w);
    for (const w of due) map.set(w.id, w);
    for (const w of todayNew) map.set(w.id, w);

    const excludeSet = new Set(map.keys());

    let weak = [];
    if (!tri) {
      const weakLimit = weekly ? WEAK_WEEKLY_LIMIT : WEAK_DAILY_LIMIT;
      weak = pickWeakWords(t, weakLimit, excludeSet);
      for (const w of weak) map.set(w.id, w);
    }

    const all = Array.from(map.values());
    const newBucket = all.filter(w => setNew.has(w.id));
    const revBucket = all.filter(w => !setNew.has(w.id));

    newBucket.sort((a,b)=> orderKey(seed, a.id) - orderKey(seed, b.id));
    revBucket.sort((a,b)=> orderKey(seed, a.id) - orderKey(seed, b.id));

    const mixed = [];
    let iN=0, iR=0;
    while (iN < newBucket.length || iR < revBucket.length) {
      if (iR < revBucket.length) mixed.push(revBucket[iR++]);
      if (iN < newBucket.length) mixed.push(newBucket[iN++]);
    }

    return {
      mode,
      list: mixed,
      newCount: todayNew.length,
      dueCount: due.length,
      weeklyCount: weeklyPack.length,
      triCount: triPack.length,
      weakCount: weak.length
    };
  };

  // ======= DAILY CYCLE =======
  const getCycleStartForDate = (t) => state.settings?.cycleStartByDate?.[t] || null;

  const buildCycleWithinDay = (startHHMM) => {
    const startMin = timeToMin(startHHMM);
    const endMin = 1439;
    const available = Math.max(0, endMin - startMin);

    const mins = SHAPE_OFFSETS_MIN.map(off => {
      const frac = SHAPE_SPAN_MIN ? (off / SHAPE_SPAN_MIN) : 0;
      return startMin + Math.round(frac * available);
    });

    for (let i = 1; i < mins.length; i++) {
      if (mins[i] <= mins[i-1]) mins[i] = Math.min(mins[i-1] + 1, endMin);
      else mins[i] = Math.min(mins[i], endMin);
    }
    mins[0] = Math.min(Math.max(mins[0], 0), endMin);

    return mins.map(minToHHMM);
  };

  const getDailyCycle = (t) => {
    const s = getCycleStartForDate(t);
    if (!s) return DEFAULT_DAILY_CYCLE.slice();
    return buildCycleWithinDay(s);
  };

  // ======= IN/PRINT =======
  const escapeHtml = (s) => (s ?? "").toString()
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");

  const vocabCellHtml = (w, showCreatedDate) => {
    const base = escapeHtml(w.vocab);
    if (!showCreatedDate) return base;
    return `${base} <sup class="createdDate">${escapeHtml(w.addedDate)}</sup>`;
  };

  const openPrintWindow = (t, list, cycle, note = "", showCreatedDate = false) => {
    const title = `Bài kiểm tra - ${t}`;
    const scheduleText = `Chu kỳ ngắt quãng: ${cycle.join(" · ")}`;
    const blankCount = 1 + cycle.length;

    const headCells = [
      "<th>Từ vựng</th>",
      "<th>Kana</th>",
      "<th>Nghĩa Việt</th>",
      "<th>Học mới</th>",
      ...cycle.map(h => `<th>${escapeHtml(h)}</th>`)
    ].join("");

    const rows = list.map(w => {
      const blanks = Array.from({ length: blankCount }, () => "<td></td>").join("");
      return `<tr>
        <td class="jp">${showCreatedDate ? `${escapeHtml(w.vocab)} <sup class="createdDate">${escapeHtml(w.addedDate)}</sup>` : `${escapeHtml(w.vocab)}`}</td>
        <td class="jp">${escapeHtml(w.kana)}</td>
        <td class="vi">${escapeHtml(w.meaning)}</td>
        ${blanks}
      </tr>`;
    }).join("");

    const vocabW = 14, kanaW = 12, meaningW = 22;
    const remain = 100 - (vocabW + kanaW + meaningW);
    const blankW = remain / blankCount;

    const colgroup = `
      <col style="width:${vocabW}%;">
      <col style="width:${kanaW}%;">
      <col style="width:${meaningW}%;">
      ${Array.from({length: blankCount}, () => `<col style="width:${blankW.toFixed(2)}%;">`).join("")}
    `;

    const html = `<!doctype html>
<html lang="vi"><head><meta charset="utf-8" />
<title>${escapeHtml(title)}</title>
<style>
  * { box-sizing: border-box; }
  body { margin: 0; color: #000; background: #fff; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
  @page { size: A4 landscape; margin: 7mm; }
  .btn { margin: 0 0 5mm; padding: 10px 14px; font-size: 16px; font-family: "Times New Roman", Times, serif; }
  @media print { .btn { display: none; } }
  h1 { margin: 0 0 3.5mm; font-size: 20px; font-family: "Times New Roman", Times, serif; }
  .headerline{
    margin: 0 0 4mm; font-size: 16px; padding: 9px 11px;
    border: 2px solid #000; border-radius: 10px; font-family: "Times New Roman", Times, serif;
  }
  sup.createdDate{ font-size: 11px; font-weight: 800; }
  table { width: 100%; border-collapse: collapse; table-layout: fixed; font-size: 16px; }
  thead { display: table-header-group; }
  tr { page-break-inside: avoid; }
  th, td { border: 1.4px solid #000; padding: 6px; vertical-align: top; line-height: 1.15; overflow-wrap: anywhere; word-break: break-word; }
  th { font-weight: 800; font-family: "Times New Roman", Times, serif; text-align: center; }
  td.jp { font-family: "Noto Sans JP", "Yu Gothic", "Hiragino Kaku Gothic ProN", Arial, sans-serif; }
  td.vi { font-family: "Times New Roman", Times, serif; }
  th:nth-child(n+4), td:nth-child(n+4) { text-align: center; }
  td { height: 50px; }
</style>
</head>
<body>
  <button class="btn" onclick="window.print()">In / Lưu PDF</button>
  <h1>${escapeHtml(title)}</h1>
  <div class="headerline"><b>${escapeHtml(scheduleText)}</b>${note ? " • " + escapeHtml(note) : ""} • Tổng số từ: ${list.length}</div>
  <table>
    <colgroup>${colgroup}</colgroup>
    <thead><tr>${headCells}</tr></thead>
    <tbody>${rows}</tbody>
  </table>
</body></html>`;

    const w = window.open("", "_blank");
    if (!w) return false;
    w.document.open();
    w.document.write(html);
    w.document.close();
    return true;
  };

  // ======= SNAPSHOT/RESULTS =======
  const ensureSnap = (t, ids) => {
    if (!state.generatedByDate) state.generatedByDate = {};
    if (!state.generatedByDate[t]) {
      state.generatedByDate[t] = { ids: ids.slice(), results: {}, finalized: false, finalizedAt: null, mode: "daily", note: "" };
    }
    const snap = state.generatedByDate[t];
    if (!snap.ids) snap.ids = ids.slice();
    if (!snap.results) snap.results = {};
    if (snap.finalized == null) snap.finalized = false;

    for (const id of snap.ids) {
      if (!Array.isArray(snap.results[id])) snap.results[id] = Array.from({ length: BLANK_COLS }, () => null);
      if (snap.results[id].length !== BLANK_COLS) {
        const arr = snap.results[id].slice(0, BLANK_COLS);
        while (arr.length < BLANK_COLS) arr.push(null);
        snap.results[id] = arr;
      }
    }
    return snap;
  };

  const lastOutcome = (arr) => {
    for (let i = arr.length - 1; i >= 0; i--) {
      if (arr[i] === 1) return "pass";
      if (arr[i] === 0) return "fail";
    }
    return null;
  };

  const missingCount = (snap) => {
    let miss = 0;
    for (const id of snap.ids) {
      const arr = snap.results?.[id];
      if (!arr || !lastOutcome(arr)) miss++;
    }
    return miss;
  };

  // ======= UI HOOKS =======
  const $ = (id) => document.getElementById(id);

  const todayPill = $("todayPill");
  const modePill  = $("modePill");
  const newPill   = $("newPill");
  const duePill   = $("duePill");
  const weakPill  = $("weakPill");
  const totalPill = $("totalPill");

  const reviewNotice = $("reviewNotice");
  const bulkSection = $("bulkSection");

  const bulkText = $("bulkText");
  const bulkAddBtn = $("bulkAddBtn");
  const bulkClearBtn = $("bulkClearBtn");

  const startTimeInput = $("startTimeInput");
  const applyStartTimeBtn = $("applyStartTimeBtn");
  const resetStartTimeBtn = $("resetStartTimeBtn");
  const startTimeHint = $("startTimeHint");

  const genBtn = $("genBtn");
  const msg = $("msg");

  const resultActions = $("resultActions");
  const finalizeBtn = $("finalizeBtn");
  const markPassAllBtn = $("markPassAllBtn");
  const clearMarksBtn = $("clearMarksBtn");
  const resultHint = $("resultHint");

  const scheduleHeader = $("scheduleHeader");
  const previewHeadRow = $("previewHeadRow");
  const previewBody = $("previewBody");

  const historyDateSelect = $("historyDateSelect");
  const historyBody = $("historyBody");
  const clearLocalBtn = $("clearLocalBtn");

  // ======= BULK INPUT =======
  const parseLines = (text) => {
    const lines = text.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    const items = [];
    for (const line of lines) {
      const parts = line.split(/\t|\s*\|\s*|\s*,\s*/).map(x=>x.trim()).filter(Boolean);
      if (parts.length >= 3) {
        const [v,k,m] = parts;
        items.push({vocab:v, kana:k, meaning:m});
      }
    }
    return items;
  };

  bulkClearBtn.addEventListener("click", () => {
    bulkText.value = "";
    bulkText.focus();
  });

  bulkAddBtn.addEventListener("click", () => {
    const t = todayStr();
    ensureStartDate();

    if (isReviewOnlyDay(t)) {
      msg.innerHTML = `<span class="warn">Hôm nay là ngày tổng ôn 7/21 → tạm không thêm từ mới. Mai thêm tiếp nhé.</span>`;
      return;
    }

    let remaining = DAILY_NEW_LIMIT - countNewOnDate(t);
    if (remaining <= 0) return;

    const items = parseLines(bulkText.value);
    if (items.length === 0) {
      msg.innerHTML = `<span class="err">Không parse được dòng nào. Hãy dùng TAB hoặc | hoặc , để tách 3 cột.</span>`;
      return;
    }

    if (!state.startDate) state.startDate = t;

    let added = 0;
    for (const it of items) {
      if (remaining <= 0) break;

      const id = crypto?.randomUUID
        ? crypto.randomUUID()
        : String(Date.now()) + Math.random().toString(16).slice(2);

      state.words.push(normalizeCard({
        id,
        vocab: it.vocab,
        kana: it.kana,
        meaning: it.meaning,
        addedDate: t,

        ef: 2.5,
        reps: 0,
        interval: 0,
        due: t,
        lastReviewed: null,
        lapses: 0,
        failStreak: 0,
        lastQ: null
      }));

      remaining--;
      added++;
    }

    save(state);
    bulkText.value = "";
    msg.innerHTML = `<span class="ok">Đã thêm ${added} từ (còn thiếu ${DAILY_NEW_LIMIT - countNewOnDate(t)} từ để đủ 50).</span>`;
    render();
  });

  // ======= START TIME =======
  applyStartTimeBtn.addEventListener("click", () => {
    const t = todayStr();
    const v = (startTimeInput.value || "").trim();
    if (!v) {
      msg.innerHTML = `<span class="err">Bạn chưa chọn giờ bắt đầu.</span>`;
      return;
    }
    state.settings.cycleStartByDate[t] = v;
    save(state);
    render();
    msg.innerHTML = `<span class="ok">Đã áp dụng giờ bắt đầu hôm nay: ${escapeHtml(v)}.</span>`;
  });

  resetStartTimeBtn.addEventListener("click", () => {
    const t = todayStr();
    if (state.settings?.cycleStartByDate?.[t]) delete state.settings.cycleStartByDate[t];
    save(state);
    render();
    msg.innerHTML = `<span class="ok">Đã về mốc cố định mặc định.</span>`;
  });

  // ======= GENERATE / REPRINT =======
  genBtn.addEventListener("click", () => {
    const t = todayStr();
    ensureStartDate();

    const snap = state.generatedByDate?.[t];

    // Reprint
    if (snap) {
      const cycle = getDailyCycle(t);
      const ids = snap.ids || [];
      const list = ids.map(id => state.words.find(w => w.id === id)).filter(Boolean).map(normalizeCard);

      if (list.length === 0) {
        msg.innerHTML = `<span class="err">Không tìm thấy dữ liệu đề đã tạo (có thể bạn đã xóa từ).</span>`;
        return;
      }

      const showCreatedDate = (snap.mode === "tri"); // chỉ tri mới show date
      const ok = openPrintWindow(t, list, cycle, snap.note || "", showCreatedDate);
      if (!ok) {
        msg.innerHTML = `<span class="err">Trình duyệt chặn pop-up. Hãy cho phép pop-up rồi bấm lại.</span>`;
        return;
      }

      msg.innerHTML = `<span class="ok">Đang in lại đề (thứ tự giữ nguyên). SR chỉ cập nhật khi bạn bấm “Hoàn tất”.</span>`;
      return;
    }

    // Create new
    const pool = buildSessionPool(t);
    if (pool.list.length === 0) {
      msg.innerHTML = `<span class="warn">Hôm nay chưa có gì để tạo đề.</span>`;
      return;
    }

    const cycle = getDailyCycle(t);
    const showCreatedDate = (pool.mode === "tri");

    const note =
      pool.mode === "tri"
        ? `TỔNG ÔN 21 NGÀY (cộng dồn): ôn ${pool.triCount} từ (từ ${state.startDate} → ${t}) • Due hôm nay: ${pool.dueCount}`
        : pool.mode === "weekly"
          ? `TỔNG ÔN 7 NGÀY: ôn ${pool.weeklyCount} từ (7 ngày gần nhất) • Due: ${pool.dueCount} • Weak: ${pool.weakCount} • New: ${pool.newCount}`
          : `New: ${pool.newCount} • Due: ${pool.dueCount} • Weak: ${pool.weakCount}`;

    const ok = openPrintWindow(t, pool.list, cycle, note, showCreatedDate);
    if (!ok) {
      msg.innerHTML = `<span class="err">Trình duyệt chặn pop-up. Hãy cho phép pop-up rồi bấm lại.</span>`;
      return;
    }

    state.generatedByDate[t] = {
      ids: pool.list.map(w => w.id),
      results: {},
      finalized: false,
      finalizedAt: null,
      mode: pool.mode,
      note
    };
    ensureSnap(t, state.generatedByDate[t].ids);

    save(state);
    render();

    msg.innerHTML = `<span class="ok">Đã tạo đề hôm nay (${pool.mode === "tri" ? "TỔNG ÔN 21" : pool.mode === "weekly" ? "TỔNG ÔN 7" : "ngày thường"}). Làm xong quay lại chấm ✓/✗ rồi bấm “Hoàn tất”.</span>`;
  });

  // ======= MARKING CLICK (preview table) =======
  previewBody.addEventListener("click", (e) => {
    const td = e.target.closest("td.markable");
    if (!td) return;

    const t = todayStr();
    const snap = state.generatedByDate?.[t];
    if (!snap || snap.finalized) return;

    const id = td.dataset.id;
    const idx = Number(td.dataset.try);
    if (!id || !Number.isFinite(idx)) return;

    ensureSnap(t, snap.ids);

    const arr = snap.results[id];
    const cur = arr[idx];
    const next = (cur === null) ? 1 : (cur === 1) ? 0 : null;
    arr[idx] = next;

    save(state);

    td.classList.remove("pass", "fail");
    td.textContent = "";
    if (next === 1) { td.classList.add("pass"); td.textContent = "✓"; }
    else if (next === 0) { td.classList.add("fail"); td.textContent = "✗"; }

    const miss = missingCount(ensureSnap(t, snap.ids));
    finalizeBtn.disabled = miss > 0;
    resultHint.innerHTML = miss === 0
      ? `<span class="ok">Đã có kết quả cho tất cả từ. Có thể bấm “Hoàn tất & cập nhật SR”.</span>`
      : `<span class="warn">Còn ${miss} từ chưa có kết quả (click ô để đổi ✓ / ✗ / trống).</span>`;
  });

  markPassAllBtn.addEventListener("click", () => {
    const t = todayStr();
    const snap = state.generatedByDate?.[t];
    if (!snap || snap.finalized) return;

    ensureSnap(t, snap.ids);
    for (const id of snap.ids) {
      const arr = snap.results[id];
      if (!lastOutcome(arr)) arr[arr.length - 1] = 1;
    }
    save(state);
    render();
    msg.innerHTML = `<span class="ok">Đã đánh dấu Đạt cho các từ còn trống (ở cột cuối).</span>`;
  });

  clearMarksBtn.addEventListener("click", () => {
    const t = todayStr();
    const snap = state.generatedByDate?.[t];
    if (!snap || snap.finalized) return;

    const ok = window.confirm("Xóa toàn bộ đánh dấu kết quả hôm nay? (Không thể hoàn tác)");
    if (!ok) return;

    ensureSnap(t, snap.ids);
    for (const id of snap.ids) snap.results[id] = Array.from({ length: BLANK_COLS }, () => null);

    save(state);
    render();
    msg.innerHTML = `<span class="ok">Đã xóa toàn bộ đánh dấu hôm nay.</span>`;
  });

  finalizeBtn.addEventListener("click", () => {
    const t = todayStr();
    const snap = state.generatedByDate?.[t];
    if (!snap || snap.finalized) return;

    ensureSnap(t, snap.ids);
    const miss = missingCount(snap);
    if (miss > 0) {
      msg.innerHTML = `<span class="warn">Còn ${miss} từ chưa có kết quả. Hãy đánh dấu đủ rồi hãy “Hoàn tất”.</span>`;
      return;
    }

    for (const id of snap.ids) {
      const card = state.words.find(x => x.id === id);
      if (!card) continue;
      normalizeCard(card);

      const outcome = lastOutcome(snap.results[id]);
      const quality = (outcome === "pass") ? 4 : 2; // ✓ good, ✗ again
      sm2Update(card, quality, t);
    }

    snap.finalized = true;
    snap.finalizedAt = new Date().toISOString();

    save(state);
    render();

    msg.innerHTML = `<span class="ok">Đã cập nhật SR. Ngày thường: due + weak + new. Ngày 7: tổng ôn 7 ngày. Ngày 21/42/63…: tổng ôn 21 (ôn hết tất cả từ).</span>`;
  });

  // ======= HISTORY (edit/delete) =======
  let editingId = null;

  const getAllDatesDesc = () => {
    const set = new Set(state.words.map(w => w.addedDate));
    return Array.from(set).sort((a,b)=> ymdToDay(b) - ymdToDay(a));
  };

  const renderHistoryTable = (d) => {
    const rows = state.words
      .filter(w => w.addedDate === d)
      .map(normalizeCard);

    if (rows.length === 0) {
      historyBody.innerHTML = `<tr><td colspan="4" class="muted">Không có từ nào trong ngày này.</td></tr>`;
      return;
    }

    historyBody.innerHTML = rows.map(w => {
      const isEdit = editingId === w.id;

      if (isEdit) {
        return `
          <tr data-id="${escapeHtml(w.id)}">
            <td><input class="editVocab" value="${escapeHtml(w.vocab)}" /></td>
            <td><input class="editKana" value="${escapeHtml(w.kana)}" /></td>
            <td><input class="editMeaning" value="${escapeHtml(w.meaning)}" /></td>
            <td>
              <button class="btnMini" data-action="save" data-id="${escapeHtml(w.id)}">Lưu</button>
              <button class="btnMini" data-action="cancel" data-id="${escapeHtml(w.id)}">Hủy</button>
            </td>
          </tr>
        `;
      }

      return `
        <tr data-id="${escapeHtml(w.id)}">
          <td>${escapeHtml(w.vocab)}</td>
          <td>${escapeHtml(w.kana)}</td>
          <td>${escapeHtml(w.meaning)}</td>
          <td>
            <button class="btnMini" data-action="edit" data-id="${escapeHtml(w.id)}">Sửa</button>
            <button class="btnMini danger" data-action="delete" data-id="${escapeHtml(w.id)}">Xóa</button>
          </td>
        </tr>
      `;
    }).join("");
  };

  historyBody.addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;

    const action = btn.dataset.action;
    const id = btn.dataset.id;
    const d = historyDateSelect.value;
    if (!id) return;

    if (action === "edit") { editingId = id; renderHistoryTable(d); return; }
    if (action === "cancel") { editingId = null; renderHistoryTable(d); return; }

    if (action === "save") {
      const tr = btn.closest("tr");
      const vocab = tr.querySelector(".editVocab")?.value?.trim() ?? "";
      const kana = tr.querySelector(".editKana")?.value?.trim() ?? "";
      const meaning = tr.querySelector(".editMeaning")?.value?.trim() ?? "";

      if (!vocab || !kana || !meaning) {
        msg.innerHTML = `<span class="err">Không được để trống khi lưu chỉnh sửa.</span>`;
        return;
      }

      const w = state.words.find(x => x.id === id);
      if (!w) return;

      w.vocab = vocab;
      w.kana = kana;
      w.meaning = meaning;

      save(state);
      editingId = null;
      render();
      msg.innerHTML = `<span class="ok">Đã lưu chỉnh sửa.</span>`;
      return;
    }

    if (action === "delete") {
      const ok = window.confirm("Xóa từ này khỏi local? (Không thể hoàn tác)");
      if (!ok) return;

      state.words = state.words.filter(x => x.id !== id);
      if (editingId === id) editingId = null;

      save(state);
      render();
      msg.innerHTML = `<span class="ok">Đã xóa 1 từ.</span>`;
      return;
    }
  });

  historyDateSelect.addEventListener("change", () => {
    editingId = null;
    renderHistoryTable(historyDateSelect.value);
  });

  // ======= CLEAR LOCAL =======
  clearLocalBtn.addEventListener("click", () => {
    const ok = window.confirm("Xóa toàn bộ dữ liệu local trên máy này? (Không thể hoàn tác)");
    if (!ok) return;
    localStorage.removeItem(KEY);
    state = defaultState();
    bulkText.value = "";
    msg.innerHTML = `<span class="ok">Đã xóa dữ liệu local và reset toàn bộ hệ thống.</span>`;
    render();
  });

  // ======= RENDER =======
  const render = () => {
    ensureStartDate();

    const t = todayStr();
    const mode = getModeForDate(t);
    const pool = buildSessionPool(t);
    const snap = state.generatedByDate?.[t] || null;

    const cycle = getDailyCycle(t);
    const newCount = countNewOnDate(t);
    const dueCount = dueCountOnDate(t);

    todayPill.textContent = `Hôm nay: ${t}`;
    modePill.textContent =
      mode === "tri" ? "Chế độ: TỔNG ÔN 21 (ôn hết tất cả)" :
      mode === "weekly" ? "Chế độ: TỔNG ÔN 7" :
      "Chế độ: Ngày thường";

    newPill.textContent = `Từ mới hôm nay: ${newCount}/${DAILY_NEW_LIMIT}`;
    duePill.textContent = `Đến hạn hôm nay: ${dueCount}`;
    weakPill.textContent = `Chèn từ yếu (đề): ${pool.weakCount}`;
    totalPill.textContent = `Tổng từ đã lưu: ${state.words.length}`;

    // Bulk show/hide by mode
    const reviewOnly = (mode === "weekly" || mode === "tri");
    bulkSection.style.display = reviewOnly ? "none" : "block";

    if (reviewOnly) {
      reviewNotice.style.display = "block";
      reviewNotice.innerHTML = mode === "tri"
        ? `Hôm nay là <b>TỔNG ÔN 21 NGÀY (ôn hết tất cả từ)</b> → ôn lại toàn bộ từ từ <b>${escapeHtml(state.startDate || t)}</b> đến <b>${escapeHtml(t)}</b>. Tạm ẩn nhập từ mới.`
        : `Hôm nay là <b>TỔNG ÔN 7 NGÀY</b> → ôn lại tất cả từ của 7 ngày gần nhất. Tạm ẩn nhập từ mới.`;
    } else {
      reviewNotice.style.display = "none";
      reviewNotice.textContent = "";
    }

    bulkAddBtn.disabled = reviewOnly ? true : (newCount >= DAILY_NEW_LIMIT);
    bulkClearBtn.disabled = reviewOnly;
    bulkText.disabled = reviewOnly;

    genBtn.textContent = snap ? "In lại đề hôm nay"
      : mode === "tri" ? "Tạo đề tổng ôn 21"
      : mode === "weekly" ? "Tạo đề tổng ôn 7"
      : "Tạo file kiểm tra hôm nay";

    // Start time hint
    const start = getCycleStartForDate(t);
    startTimeInput.value = start || "";
    startTimeHint.textContent = start
      ? `Giờ bắt đầu: ${start} → mốc trong ngày: ${cycle.join(" · ")} (<= 23:59)`
      : `Đang dùng mốc cố định: ${DEFAULT_DAILY_CYCLE.join(" · ")}`;

    scheduleHeader.innerHTML = `<b>Chu kỳ ngắt quãng:</b> ${cycle.map(escapeHtml).join(" · ")}`;

    // Result actions
    if (snap) {
      ensureSnap(t, snap.ids || []);
      resultActions.style.display = "flex";

      if (snap.finalized) {
        finalizeBtn.disabled = true;
        markPassAllBtn.disabled = true;
        clearMarksBtn.disabled = true;
        resultHint.innerHTML = `<span class="ok">Đã hoàn tất và cập nhật SR cho ngày ${t}.</span>`;
      } else {
        const miss = missingCount(snap);
        finalizeBtn.disabled = miss > 0;
        markPassAllBtn.disabled = false;
        clearMarksBtn.disabled = false;
        resultHint.innerHTML = miss === 0
          ? `<span class="ok">Đã có kết quả cho tất cả từ. Có thể bấm “Hoàn tất & cập nhật SR”.</span>`
          : `<span class="warn">Còn ${miss} từ chưa có kết quả (click ô để đổi ✓ / ✗ / trống).</span>`;
      }
    } else {
      resultActions.style.display = "none";
      resultHint.textContent = "";
    }

    // Message
    if (snap && !snap.finalized) {
      msg.innerHTML = `<span class="warn">Bạn đã tạo đề hôm nay. Làm xong quay lại chấm ✓/✗ và bấm “Hoàn tất”.</span>`;
    } else if (snap && snap.finalized) {
      msg.innerHTML = `<span class="ok">Hôm nay đã cập nhật SR. Ngày thường: due + weak + new. Ngày 7: tổng ôn 7. Ngày 21/42/63…: tổng ôn 21 (ôn hết tất cả).</span>`;
    } else if (pool.list.length === 0) {
      msg.innerHTML = `<span class="warn">Hôm nay chưa có gì để tạo đề.</span>`;
    } else if (!reviewOnly && newCount < DAILY_NEW_LIMIT) {
      msg.innerHTML = `<span class="warn">Chưa đủ 50 từ mới, nhưng vẫn có thể tạo đề nhờ due/weak. (Muốn “50/ngày” thì nhập thêm.)</span>`;
    } else {
      const heavy = mode === "tri" && pool.list.length > 700;
      msg.innerHTML = heavy
        ? `<span class="warn">TỔNG ÔN 21 đang rất lớn (${pool.list.length} từ). In PDF có thể nặng — bạn có thể in và ôn theo từng phần.</span>`
        : `<span class="ok">Sẵn sàng tạo đề. Review: ${pool.list.length} từ.</span>`;
    }

    // Preview header
    const ths = [
      `<th style="width:12%;">Từ vựng</th>`,
      `<th style="width:10%;">Kana</th>`,
      `<th style="width:18%;">Nghĩa Việt</th>`,
      `<th style="width:10%;">Học mới</th>`,
      ...cycle.map(h => `<th style="width:10%;">${escapeHtml(h)}</th>`)
    ];
    previewHeadRow.innerHTML = ths.join("");

    // Preview list: use snap if exists else live pool
    const list = (() => {
      if (!snap) return pool.list;
      const ids = snap.ids || [];
      return ids.map(id => state.words.find(w => w.id === id)).filter(Boolean).map(normalizeCard);
    })();

    // Show created date only if "tổng ôn hết tất cả từ" => TRI
    const showCreatedDate = snap ? (snap.mode === "tri") : (mode === "tri");

    if (list.length === 0) {
      previewBody.innerHTML = `<tr><td colspan="${4 + cycle.length}" class="muted">Chưa có từ nào để hiển thị.</td></tr>`;
    } else {
      previewBody.innerHTML = list.map(w => {
        let blanks = "";
        if (snap && !snap.finalized) {
          ensureSnap(t, snap.ids);
          const res = snap.results?.[w.id] || Array.from({ length: BLANK_COLS }, () => null);
          blanks = res.map((v, i) => {
            const cls = v === 1 ? "markable pass" : v === 0 ? "markable fail" : "markable";
            const txt = v === 1 ? "✓" : v === 0 ? "✗" : "";
            return `<td class="blank ${cls}" data-id="${escapeHtml(w.id)}" data-try="${i}">${txt}</td>`;
          }).join("");
        } else {
          blanks = Array.from({ length: BLANK_COLS }, () => `<td class="blank"></td>`).join("");
        }

        return `<tr>
          <td>${vocabCellHtml(w, showCreatedDate)}</td>
          <td>${escapeHtml(w.kana)}</td>
          <td>${escapeHtml(w.meaning)}</td>
          ${blanks}
        </tr>`;
      }).join("");
    }

    // History select/table
    const dates = getAllDatesDesc();
    if (dates.length === 0) {
      historyDateSelect.innerHTML = `<option value="">(Chưa có dữ liệu)</option>`;
      historyBody.innerHTML = `<tr><td colspan="4" class="muted">Chưa có từ nào được lưu.</td></tr>`;
    } else {
      const current = historyDateSelect.value || dates[0];
      historyDateSelect.innerHTML = dates.map(d => {
        const n = countNewOnDate(d);
        return `<option value="${d}" ${d===current?"selected":""}>${d} — ${n} từ</option>`;
      }).join("");
      renderHistoryTable(historyDateSelect.value || dates[0]);
    }
  };

  // ======= INIT =======
  render();
})();
</script>
</body>
</html>
